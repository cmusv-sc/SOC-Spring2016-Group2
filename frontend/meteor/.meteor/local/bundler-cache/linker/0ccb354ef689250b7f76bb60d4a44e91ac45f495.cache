[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\nvar Iron = Package['iron:core'].Iron;\n\n/* Package-scope variables */\nvar Handler, MiddlewareStack;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/iron_middleware-stack/lib/handler.js                                                       //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\nvar Url = Iron.Url;                                                                                    // 1\n                                                                                                       // 2\nHandler = function (path, fn, options) {                                                               // 3\n  if (_.isFunction(path)) {                                                                            // 4\n    options = options || fn || {};                                                                     // 5\n    fn = path;                                                                                         // 6\n    path = '/';                                                                                        // 7\n                                                                                                       // 8\n    // probably need a better approach here to differentiate between                                   // 9\n    // Router.use(function () {}) and Router.use(MyAdminApp). In the first                             // 10\n    // case we don't want to count it as a viable server handler when we're                            // 11\n    // on the client and need to decide whether to go to the server. in the                            // 12\n    // latter case, we DO want to go to the server, potentially.                                       // 13\n    this.middleware = true;                                                                            // 14\n                                                                                                       // 15\n    if (typeof options.mount === 'undefined')                                                          // 16\n      options.mount = true;                                                                            // 17\n  }                                                                                                    // 18\n                                                                                                       // 19\n  // if fn is a function then typeof fn => 'function'                                                  // 20\n  // but note we can't use _.isObject here because that will return true if the                        // 21\n  // fn is a function OR an object.                                                                    // 22\n  if (typeof fn === 'object') {                                                                        // 23\n    options = fn;                                                                                      // 24\n    fn = options.action || 'action';                                                                   // 25\n  }                                                                                                    // 26\n                                                                                                       // 27\n  options = options || {};                                                                             // 28\n                                                                                                       // 29\n  this.options = options;                                                                              // 30\n  this.mount = options.mount;                                                                          // 31\n  this.method = (options.method && options.method.toLowerCase()) || false;                             // 32\n                                                                                                       // 33\n  // should the handler be on the 'client', 'server' or 'both'?                                        // 34\n  // XXX can't we default this to undefined in which case it's run in all                              // 35\n  // environments?                                                                                     // 36\n  this.where = options.where || 'client';                                                              // 37\n                                                                                                       // 38\n  // if we're mounting at path '/foo' then this handler should also handle                             // 39\n  // '/foo/bar' and '/foo/bar/baz'                                                                     // 40\n  if (this.mount)                                                                                      // 41\n    options.end = false;                                                                               // 42\n                                                                                                       // 43\n  // set the name                                                                                      // 44\n  if (options.name)                                                                                    // 45\n    this.name = options.name;                                                                          // 46\n  else if (typeof path === 'string' && path.charAt(0) !== '/')                                         // 47\n    this.name = path;                                                                                  // 48\n  else if (fn && fn.name)                                                                              // 49\n    this.name = fn.name;                                                                               // 50\n  else if (typeof path === 'string' && path !== '/')                                                   // 51\n    this.name = path.split('/').slice(1).join('.');                                                    // 52\n                                                                                                       // 53\n  // if the path is explicitly set on the options (e.g. legacy router support)                         // 54\n  // then use that                                                                                     // 55\n  // otherwise use the path argument which could also be a name                                        // 56\n  path = options.path || path;                                                                         // 57\n                                                                                                       // 58\n  if (typeof path === 'string' && path.charAt(0) !== '/')                                              // 59\n    path = '/' + path;                                                                                 // 60\n                                                                                                       // 61\n  this.path = path;                                                                                    // 62\n  this.compiledUrl = new Url(path, options);                                                           // 63\n                                                                                                       // 64\n  if (_.isString(fn)) {                                                                                // 65\n    this.handle = function handle () {                                                                 // 66\n      // try to find a method on the current thisArg which might be a Controller                       // 67\n      // for example.                                                                                  // 68\n      var func = this[fn];                                                                             // 69\n                                                                                                       // 70\n      if (typeof func !== 'function')                                                                  // 71\n        throw new Error(\"No method named \" + JSON.stringify(fn) + \" found on handler.\");               // 72\n                                                                                                       // 73\n      return func.apply(this, arguments);                                                              // 74\n    };                                                                                                 // 75\n  } else if (_.isFunction(fn)) {                                                                       // 76\n    // or just a regular old function                                                                  // 77\n    this.handle = fn;                                                                                  // 78\n  }                                                                                                    // 79\n};                                                                                                     // 80\n                                                                                                       // 81\n/**                                                                                                    // 82\n * Returns true if the path matches the handler's compiled url, method                                 // 83\n * and environment (e.g. client/server). If no options.method or options.where                         // 84\n * is provided, then only the path will be used to test.                                               // 85\n */                                                                                                    // 86\nHandler.prototype.test = function (path, options) {                                                    // 87\n  options = options || {};                                                                             // 88\n                                                                                                       // 89\n  var isUrlMatch = this.compiledUrl.test(path);                                                        // 90\n  var isMethodMatch = true;                                                                            // 91\n  var isEnvMatch = true;                                                                               // 92\n                                                                                                       // 93\n  if (this.method && options.method)                                                                   // 94\n    isMethodMatch = this.method == options.method.toLowerCase();                                       // 95\n                                                                                                       // 96\n  if (options.where)                                                                                   // 97\n    isEnvMatch = this.where == options.where;                                                          // 98\n                                                                                                       // 99\n  return isUrlMatch && isMethodMatch && isEnvMatch;                                                    // 100\n};                                                                                                     // 101\n                                                                                                       // 102\nHandler.prototype.params = function (path) {                                                           // 103\n  return this.compiledUrl.params(path);                                                                // 104\n};                                                                                                     // 105\n                                                                                                       // 106\nHandler.prototype.resolve = function (params, options) {                                               // 107\n  return this.compiledUrl.resolve(params, options);                                                    // 108\n};                                                                                                     // 109\n                                                                                                       // 110\n/**                                                                                                    // 111\n * Returns a new cloned Handler.                                                                       // 112\n * XXX problem is here because we're not storing the original path.                                    // 113\n */                                                                                                    // 114\nHandler.prototype.clone = function () {                                                                // 115\n  var clone = new Handler(this.path, this.handle, this.options);                                       // 116\n  // in case the original function had a name                                                          // 117\n  clone.name = this.name;                                                                              // 118\n  return clone;                                                                                        // 119\n};                                                                                                     // 120\n                                                                                                       // 121\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/iron_middleware-stack/lib/middleware_stack.js                                              //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\nvar Url = Iron.Url;                                                                                    // 1\nvar assert = Iron.utils.assert;                                                                        // 2\nvar defaultValue = Iron.utils.defaultValue;                                                            // 3\n                                                                                                       // 4\n/**                                                                                                    // 5\n * Connect inspired middleware stack that works on the client and the server.                          // 6\n *                                                                                                     // 7\n * You can add handlers to the stack for various paths. Those handlers can run                         // 8\n * on the client or server. Then you can dispatch into the stack with a                                // 9\n * given path by calling the dispatch method. This goes down the stack looking                         // 10\n * for matching handlers given the url and environment (client/server). If we're                       // 11\n * on the client and we should make a trip to the server, the onServerDispatch                         // 12\n * callback is called.                                                                                 // 13\n *                                                                                                     // 14\n * The middleware stack supports the Connect API. But it also allows you to                            // 15\n * specify a context so we can have one context object (like a Controller) that                        // 16\n * is a consistent context for each handler function called on a dispatch.                             // 17\n *                                                                                                     // 18\n */                                                                                                    // 19\nMiddlewareStack = function () {                                                                        // 20\n  this._stack = [];                                                                                    // 21\n  this.length = 0;                                                                                     // 22\n};                                                                                                     // 23\n                                                                                                       // 24\nMiddlewareStack.prototype._create = function (path, fn, options) {                                     // 25\n  var handler = new Handler(path, fn, options);                                                        // 26\n  var name = handler.name;                                                                             // 27\n                                                                                                       // 28\n  if (name) {                                                                                          // 29\n    if (_.has(this._stack, name)) {                                                                    // 30\n      throw new Error(\"Handler with name '\" + name + \"' already exists.\");                             // 31\n    }                                                                                                  // 32\n    this._stack[name] = handler;                                                                       // 33\n  }                                                                                                    // 34\n                                                                                                       // 35\n  return handler;                                                                                      // 36\n};                                                                                                     // 37\n                                                                                                       // 38\nMiddlewareStack.prototype.findByName = function (name) {                                               // 39\n  return this._stack[name];                                                                            // 40\n};                                                                                                     // 41\n                                                                                                       // 42\n/**                                                                                                    // 43\n * Push a new handler onto the stack.                                                                  // 44\n */                                                                                                    // 45\nMiddlewareStack.prototype.push = function (path, fn, options) {                                        // 46\n  var handler = this._create(path, fn, options);                                                       // 47\n  this._stack.push(handler);                                                                           // 48\n  this.length++;                                                                                       // 49\n  return handler;                                                                                      // 50\n};                                                                                                     // 51\n                                                                                                       // 52\nMiddlewareStack.prototype.append = function (/* fn1, fn2, [f3, f4]... */) {                            // 53\n  var self = this;                                                                                     // 54\n  var args = _.toArray(arguments);                                                                     // 55\n  var options = {};                                                                                    // 56\n                                                                                                       // 57\n  if (typeof args[args.length-1] === 'object')                                                         // 58\n    options = args.pop();                                                                              // 59\n                                                                                                       // 60\n  _.each(args, function (fnOrArray) {                                                                  // 61\n    if (typeof fnOrArray === 'undefined')                                                              // 62\n      return;                                                                                          // 63\n    else if (typeof fnOrArray === 'function')                                                          // 64\n      self.push(fnOrArray, options);                                                                   // 65\n    else if (_.isArray(fnOrArray))                                                                     // 66\n      self.append.apply(self, fnOrArray.concat([options]));                                            // 67\n    else                                                                                               // 68\n      throw new Error(\"Can only append functions or arrays to the MiddlewareStack\");                   // 69\n  });                                                                                                  // 70\n                                                                                                       // 71\n  return this;                                                                                         // 72\n};                                                                                                     // 73\n                                                                                                       // 74\n/**                                                                                                    // 75\n * Insert a handler at a specific index in the stack.                                                  // 76\n *                                                                                                     // 77\n * The index behavior is the same as Array.prototype.splice. If the index is                           // 78\n * greater than the stack length the handler will be appended at the end of the                        // 79\n * stack. If the index is negative, the item will be inserted \"index\" elements                         // 80\n * from the end.                                                                                       // 81\n */                                                                                                    // 82\nMiddlewareStack.prototype.insertAt = function (index, path, fn, options) {                             // 83\n  var handler = this._create(path, fn, options);                                                       // 84\n  this._stack.splice(index, 0, handler);                                                               // 85\n  this.length = this._stack.length;                                                                    // 86\n  return this;                                                                                         // 87\n};                                                                                                     // 88\n                                                                                                       // 89\n/**                                                                                                    // 90\n * Insert a handler before another named handler.                                                      // 91\n */                                                                                                    // 92\nMiddlewareStack.prototype.insertBefore = function (name, path, fn, options) {                          // 93\n  var beforeHandler;                                                                                   // 94\n  var index;                                                                                           // 95\n                                                                                                       // 96\n  if (!(beforeHandler = this._stack[name]))                                                            // 97\n    throw new Error(\"Couldn't find a handler named '\" + name + \"' on the path stack\");                 // 98\n                                                                                                       // 99\n  index = _.indexOf(this._stack, beforeHandler);                                                       // 100\n  this.insertAt(index, path, fn, options);                                                             // 101\n  return this;                                                                                         // 102\n};                                                                                                     // 103\n                                                                                                       // 104\n/**                                                                                                    // 105\n * Insert a handler after another named handler.                                                       // 106\n *                                                                                                     // 107\n */                                                                                                    // 108\nMiddlewareStack.prototype.insertAfter = function (name, path, fn, options) {                           // 109\n  var handler;                                                                                         // 110\n  var index;                                                                                           // 111\n                                                                                                       // 112\n  if (!(handler = this._stack[name]))                                                                  // 113\n    throw new Error(\"Couldn't find a handler named '\" + name + \"' on the path stack\");                 // 114\n                                                                                                       // 115\n  index = _.indexOf(this._stack, handler);                                                             // 116\n  this.insertAt(index + 1, path, fn, options);                                                         // 117\n  return this;                                                                                         // 118\n};                                                                                                     // 119\n                                                                                                       // 120\n/**                                                                                                    // 121\n * Return a new MiddlewareStack comprised of this stack joined with other                              // 122\n * stacks. Note the new stack will not have named handlers anymore. Only the                           // 123\n * handlers are cloned but not the name=>handler mapping.                                              // 124\n */                                                                                                    // 125\nMiddlewareStack.prototype.concat = function (/* stack1, stack2, */) {                                  // 126\n  var ret = new MiddlewareStack;                                                                       // 127\n  var concat = Array.prototype.concat;                                                                 // 128\n  var clonedThisStack = EJSON.clone(this._stack);                                                      // 129\n  var clonedOtherStacks = _.map(_.toArray(arguments), function (s) { return EJSON.clone(s._stack); });\n  ret._stack = concat.apply(clonedThisStack, clonedOtherStacks);                                       // 131\n  ret.length = ret._stack.length;                                                                      // 132\n  return ret;                                                                                          // 133\n};                                                                                                     // 134\n                                                                                                       // 135\n/**                                                                                                    // 136\n * Dispatch into the middleware stack, allowing the handlers to control the                            // 137\n * iteration by calling this.next();                                                                   // 138\n */                                                                                                    // 139\nMiddlewareStack.prototype.dispatch = function dispatch (url, context, done) {                          // 140\n  var self = this;                                                                                     // 141\n  var originalUrl = url;                                                                               // 142\n                                                                                                       // 143\n  assert(typeof url === 'string', \"Requires url\");                                                     // 144\n  assert(typeof context === 'object', \"Requires context object\");                                      // 145\n                                                                                                       // 146\n  url = Url.normalize(url || '/');                                                                     // 147\n                                                                                                       // 148\n  defaultValue(context, 'request', {});                                                                // 149\n  defaultValue(context, 'response', {});                                                               // 150\n  defaultValue(context, 'originalUrl', url);                                                           // 151\n                                                                                                       // 152\n  //defaultValue(context, 'location', Url.parse(originalUrl));                                         // 153\n  defaultValue(context, '_method', context.method);                                                    // 154\n  defaultValue(context, '_handlersForEnv', {client: false, server: false});                            // 155\n  defaultValue(context, '_handled', false);                                                            // 156\n                                                                                                       // 157\n  defaultValue(context, 'isHandled', function () {                                                     // 158\n    return context._handled;                                                                           // 159\n  });                                                                                                  // 160\n                                                                                                       // 161\n  defaultValue(context, 'willBeHandledOnClient', function () {                                         // 162\n    return context._handlersForEnv.client;                                                             // 163\n  });                                                                                                  // 164\n                                                                                                       // 165\n  defaultValue(context, 'willBeHandledOnServer', function () {                                         // 166\n    return context._handlersForEnv.server;                                                             // 167\n  });                                                                                                  // 168\n                                                                                                       // 169\n  var wrappedDone = function () {                                                                      // 170\n    if (done) {                                                                                        // 171\n      try {                                                                                            // 172\n        done.apply(this, arguments);                                                                   // 173\n      } catch (err) {                                                                                  // 174\n        // if we catch an error at this point in the stack we don't want it                            // 175\n        // handled in the next() iterator below. So we'll mark the error to tell                       // 176\n        // the next iterator to ignore it.                                                             // 177\n        err._punt = true;                                                                              // 178\n                                                                                                       // 179\n        // now rethrow it!                                                                             // 180\n        throw err;                                                                                     // 181\n      }                                                                                                // 182\n    }                                                                                                  // 183\n  };                                                                                                   // 184\n                                                                                                       // 185\n  var index = 0;                                                                                       // 186\n                                                                                                       // 187\n  var next = Meteor.bindEnvironment(function boundNext (err) {                                         // 188\n    var handler = self._stack[index++];                                                                // 189\n                                                                                                       // 190\n    // reset the url                                                                                   // 191\n    context.url = context.request.url = context.originalUrl;                                           // 192\n                                                                                                       // 193\n    if (!handler)                                                                                      // 194\n      return wrappedDone.call(context, err);                                                           // 195\n                                                                                                       // 196\n    if (!handler.test(url, {method: context._method}))                                                 // 197\n      return next(err);                                                                                // 198\n                                                                                                       // 199\n    // okay if we've gotten this far the handler matches our url but we still                          // 200\n    // don't know if this is a client or server handler. Let's track that.                             // 201\n    // XXX couldn't the environment be something else like cordova?                                    // 202\n    var where = Meteor.isClient ? 'client' : 'server';                                                 // 203\n                                                                                                       // 204\n    // track that we have a handler for the given environment so long as it's                          // 205\n    // not middleware created like this Router.use(function () {}). We'll assume                       // 206\n    // that if the handler is of that form we don't want to make a trip to                             // 207\n    // the client or the server for it.                                                                // 208\n    if (!handler.middleware)                                                                           // 209\n      context._handlersForEnv[handler.where] = true;                                                   // 210\n                                                                                                       // 211\n    // but if we're not actually on that env, skip to the next handler.                                // 212\n    if (handler.where !== where)                                                                       // 213\n      return next(err);                                                                                // 214\n                                                                                                       // 215\n    // get the parameters for this url from the handler's compiled path                                // 216\n    // XXX removing for now                                                                            // 217\n    //var params = handler.params(context.location.href);                                              // 218\n    //context.request.params = defaultValue(context, 'params', {});                                    // 219\n    //_.extend(context.params, params);                                                                // 220\n                                                                                                       // 221\n    // so we can call this.next()                                                                      // 222\n    // XXX this breaks with things like request.body which require that the                            // 223\n    // iterator be saved for the given function call.                                                  // 224\n    context.next = next;                                                                               // 225\n                                                                                                       // 226\n    if (handler.mount) {                                                                               // 227\n      var mountpath = Url.normalize(handler.compiledUrl.pathname);                                     // 228\n      var newUrl = url.substr(mountpath.length, url.length);                                           // 229\n      newUrl = Url.normalize(newUrl);                                                                  // 230\n      context.url = context.request.url = newUrl;                                                      // 231\n    }                                                                                                  // 232\n                                                                                                       // 233\n    try {                                                                                              // 234\n      //                                                                                               // 235\n      // The connect api says a handler signature (arity) can look like any of:                        // 236\n      //                                                                                               // 237\n      // 1) function (req, res, next)                                                                  // 238\n      // 2) function (err, req, res, next)                                                             // 239\n      // 3) function (err)                                                                             // 240\n      var arity = handler.handle.length                                                                // 241\n      var req = context.request;                                                                       // 242\n      var res = context.response;                                                                      // 243\n                                                                                                       // 244\n      // function (err, req, res, next)                                                                // 245\n      if (err && arity === 4)                                                                          // 246\n        return handler.handle.call(context, err, req, res, next);                                      // 247\n                                                                                                       // 248\n      // function (req, res, next)                                                                     // 249\n      if (!err && arity < 4)                                                                           // 250\n        return handler.handle.call(context, req, res, next);                                           // 251\n                                                                                                       // 252\n      // default is function (err) so punt the error down the stack                                    // 253\n      // until we either find a handler who likes to deal with errors or we call                       // 254\n      // out                                                                                           // 255\n      return next(err);                                                                                // 256\n    } catch (err) {                                                                                    // 257\n      if (err._punt)                                                                                   // 258\n        // ignore this error and throw it down the stack                                               // 259\n        throw err;                                                                                     // 260\n      else                                                                                             // 261\n        // see if the next handler wants to deal with the error                                        // 262\n        next(err);                                                                                     // 263\n    } finally {                                                                                        // 264\n      // we'll put this at the end because some middleware                                             // 265\n      // might want to decide what to do based on whether we've                                        // 266\n      // been handled \"yet\". If we set this to true before the handler                                 // 267\n      // is called, there's no way for the handler to say, if we haven't been                          // 268\n      // handled yet go to the server, for example.                                                    // 269\n      context._handled = true;                                                                         // 270\n      context.next = null;                                                                             // 271\n    }                                                                                                  // 272\n  });                                                                                                  // 273\n                                                                                                       // 274\n  next();                                                                                              // 275\n                                                                                                       // 276\n  context.next = null;                                                                                 // 277\n  return context;                                                                                      // 278\n};                                                                                                     // 279\n                                                                                                       // 280\nIron = Iron || {};                                                                                     // 281\nIron.MiddlewareStack = MiddlewareStack;                                                                // 282\n                                                                                                       // 283\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['iron:middleware-stack'] = {}, {\n  Handler: Handler\n});\n\n})();\n","servePath":"/packages/iron_middleware-stack.js"}]