[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar request;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/froatsnook_request/server/lib/meteor-request.js                  //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\n// Get our NPM stuff.\nrequest = Npm.require(\"request\");\n\n// Wrap request with something that can be `Meteor.wrapAsync`ed.\n//\n// @param r {Function}\n//   request-like function (request itself or request.defaults result).\n// @param key {String}\n//   Name of request function to call, like \"get\" to call request.get.  If\n//   null, then call request itself.\n// @param args {...}\n//   These args are forwarded to request.\n// @param callback {Function}\n//   Callback provided by Meteor.wrapAsync.\nvar callAsync = function(r, key /*, ...args, callback */) {\n    var allArgs = new Array(arguments.length);\n    for (var i = 0; i < allArgs.length; i++) {\n        allArgs[i] = arguments[i];\n    }\n\n    // What to pass to request.\n    var args = allArgs.slice(2, -1);\n\n    // Meteor.wrapAync callback.\n    var callback = allArgs[allArgs.length - 1];\n\n    // Call either r itself or e.g. r.get\n    var f = key ? r[key] : r;\n\n    args.push(function(error, response, body) {\n        if (error) {\n            callback(error);\n        } else {\n            callback(null, {\n                response: response,\n                body: body\n            });\n        }\n    });\n\n    f.apply(r, args);\n};\n\n// Make a sync function out of callAsync..\nvar callSync;\nif (typeof Meteor.wrapAsync === \"function\") {\n    callSync = Meteor.wrapAsync(callAsync);\n} else {\n    callSync = Meteor._wrapAsync(callAsync);\n}\n\n// Copy sync versions of these methods to request in copySyncMethods.\nvar methods = [\"put\", \"patch\", \"post\", \"head\", \"del\", \"get\", null];\n\n// Add sync methods to a request-like object (`request` itself or anything\n// returned by `request.defaults`).\nvar copySyncMethods = function(r) {\n    methods.forEach(function(method) {\n        var fullName = method ? method + \"Sync\" : \"sync\";\n        r[fullName] = function(/* args */) {\n            var args = new Array(2 + arguments.length);\n            args[0] = r;\n            args[1] = method;\n            for (var j = 0; j < arguments.length; j++) {\n                args[2 + j] = arguments[j];\n            }\n\n            return callSync.apply(this, args);\n        };\n    });\n};\n\n// Add sync methods to global request object.\ncopySyncMethods(request);\n\n// request.defaults returns a wrapper around the normal request API that\n// defaults to whatever options you pass to it.  It doesn't have getSync and\n// friends.  So replace request.defaults with a shim wrapper makes sure that\n// getSync and friends are added to the returned request wrapper.\nvar originalDefaults = request.defaults;\nrequest.defaults = function(options) {\n    var defaultedRequest = originalDefaults.call(request, options);\n    copySyncMethods(defaultedRequest);\n    return defaultedRequest;\n};\n\n\n///////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['froatsnook:request'] = {}, {\n  request: request\n});\n\n})();\n","servePath":"/packages/froatsnook_request.js"}]