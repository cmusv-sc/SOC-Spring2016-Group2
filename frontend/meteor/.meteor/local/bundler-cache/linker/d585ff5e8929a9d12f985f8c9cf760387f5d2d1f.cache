[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar ReactiveDict = Package['reactive-dict'].ReactiveDict;\nvar Template = Package.templating.Template;\nvar Iron = Package['iron:core'].Iron;\nvar Blaze = Package.blaze.Blaze;\nvar UI = Package.blaze.UI;\nvar Handlebars = Package.blaze.Handlebars;\nvar Spacebars = Package.spacebars.Spacebars;\nvar HTML = Package.htmljs.HTML;\n\n/* Package-scope variables */\nvar WaitList, Controller;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                         //\n// packages/iron_controller/lib/wait_list.js                                               //\n//                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                           //\n/*****************************************************************************/            // 1\n/* Imports */                                                                              // 2\n/*****************************************************************************/            // 3\nvar assert = Iron.utils.assert;                                                            // 4\n                                                                                           // 5\n/*****************************************************************************/            // 6\n/* Private */                                                                              // 7\n/*****************************************************************************/            // 8\n                                                                                           // 9\n/**                                                                                        // 10\n * Returns an object of computation ids starting with                                      // 11\n * the current computation and including all ancestor                                      // 12\n * computations. The data structure is an object                                           // 13\n * so we can index by id and do quick checks.                                              // 14\n */                                                                                        // 15\nvar parentComputations = function () {                                                     // 16\n  var list = {};                                                                           // 17\n  var c = Deps.currentComputation;                                                         // 18\n                                                                                           // 19\n  while (c) {                                                                              // 20\n    list[String(c._id)] = true;                                                            // 21\n    c = c._parent;                                                                         // 22\n  }                                                                                        // 23\n                                                                                           // 24\n  return list;                                                                             // 25\n};                                                                                         // 26\n                                                                                           // 27\n/**                                                                                        // 28\n * Check whether the user has called ready() and then called wait(). This                  // 29\n * can cause a condition that can be simplified to this:                                   // 30\n *                                                                                         // 31\n * dep = new Deps.Dependency;                                                              // 32\n *                                                                                         // 33\n * Deps.autorun(function () {                                                              // 34\n *   dep.depend();                                                                         // 35\n *   dep.changed();                                                                        // 36\n * });                                                                                     // 37\n */                                                                                        // 38\nvar assertNoInvalidationLoop = function (dependency) {                                     // 39\n  var parentComps = parentComputations();                                                  // 40\n  var depCompIds = _.keys(dependency._dependentsById);                                     // 41\n                                                                                           // 42\n  _.each(depCompIds, function (id) {                                                       // 43\n    assert(!parentComps[id], \"\\n\\n\\\nYou called wait() after calling ready() inside the same computation tree.\\\n\\n\\n\\\nYou can fix this problem in two possible ways:\\n\\n\\\n1) Put all of your wait() calls before any ready() calls.\\n\\\n2) Put your ready() call in its own computation with Deps.autorun.\"                        // 49\n    );                                                                                     // 50\n  });                                                                                      // 51\n};                                                                                         // 52\n                                                                                           // 53\n                                                                                           // 54\n/*****************************************************************************/            // 55\n/* WaitList */                                                                             // 56\n/*****************************************************************************/            // 57\n/**                                                                                        // 58\n * A WaitList tracks a list of reactive functions, each in its own computation.            // 59\n * The list is ready() when all of the functions return true. This list is not             // 60\n * ready (i.e. this.ready() === false) if at least one function returns false.             // 61\n *                                                                                         // 62\n * You add functions by calling the wait(fn) method. Each function is run its              // 63\n * own computation. The ready() method is a reactive method but only calls the             // 64\n * deps changed function if the overall state of the list changes from true to             // 65\n * false or from false to true.                                                            // 66\n */                                                                                        // 67\nWaitList = function () {                                                                   // 68\n  this._readyDep = new Deps.Dependency;                                                    // 69\n  this._comps = [];                                                                        // 70\n  this._notReadyCount = 0;                                                                 // 71\n};                                                                                         // 72\n                                                                                           // 73\n/**                                                                                        // 74\n * Pass a function that returns true or false.                                             // 75\n */                                                                                        // 76\nWaitList.prototype.wait = function (fn) {                                                  // 77\n  var self = this;                                                                         // 78\n                                                                                           // 79\n  var activeComp = Deps.currentComputation;                                                // 80\n                                                                                           // 81\n  assertNoInvalidationLoop(self._readyDep);                                                // 82\n                                                                                           // 83\n  // break with parent computation and grab the new comp                                   // 84\n  Deps.nonreactive(function () {                                                           // 85\n                                                                                           // 86\n    // store the cached result so we can see if it's different from one run to             // 87\n    // the next.                                                                           // 88\n    var cachedResult = null;                                                               // 89\n                                                                                           // 90\n    // create a computation for this handle                                                // 91\n    var comp = Deps.autorun(function (c) {                                                 // 92\n      // let's get the new result coerced into a true or false value.                      // 93\n      var result = !!fn();                                                                 // 94\n                                                                                           // 95\n      var oldNotReadyCount = self._notReadyCount;                                          // 96\n                                                                                           // 97\n      // if it's the first run and we're false then inc                                    // 98\n      if (c.firstRun && !result)                                                           // 99\n        self._notReadyCount++;                                                             // 100\n      else if (cachedResult !== null && result !== cachedResult && result === true)        // 101\n        self._notReadyCount--;                                                             // 102\n      else if (cachedResult !== null && result !== cachedResult && result === false)       // 103\n        self._notReadyCount++;                                                             // 104\n                                                                                           // 105\n      cachedResult = result;                                                               // 106\n                                                                                           // 107\n      if (oldNotReadyCount === 0 && self._notReadyCount > 0)                               // 108\n        self._readyDep.changed();                                                          // 109\n      else if (oldNotReadyCount > 0 && self._notReadyCount === 0)                          // 110\n        self._readyDep.changed();                                                          // 111\n    });                                                                                    // 112\n                                                                                           // 113\n    self._comps.push(comp);                                                                // 114\n                                                                                           // 115\n    if (activeComp) {                                                                      // 116\n      activeComp.onInvalidate(function () {                                                // 117\n        // keep the old computation and notReadyCount the same for one                     // 118\n        // flush cycle so that we don't end up in an intermediate state                    // 119\n        // where list.ready() is not correct.                                              // 120\n                                                                                           // 121\n        // keep the state the same until the flush cycle is complete                       // 122\n        Deps.afterFlush(function () {                                                      // 123\n          // stop the computation                                                          // 124\n          comp.stop();                                                                     // 125\n                                                                                           // 126\n          // remove the computation from the list                                          // 127\n          self._comps.splice(_.indexOf(self._comps, comp), 1);                             // 128\n                                                                                           // 129\n          if (cachedResult === false) {                                                    // 130\n            self._notReadyCount--;                                                         // 131\n                                                                                           // 132\n            if (self._notReadyCount === 0)                                                 // 133\n              self._readyDep.changed();                                                    // 134\n          }                                                                                // 135\n        });                                                                                // 136\n      });                                                                                  // 137\n    }                                                                                      // 138\n  });                                                                                      // 139\n};                                                                                         // 140\n                                                                                           // 141\nWaitList.prototype.ready = function () {                                                   // 142\n  this._readyDep.depend();                                                                 // 143\n  return this._notReadyCount === 0;                                                        // 144\n};                                                                                         // 145\n                                                                                           // 146\nWaitList.prototype.stop = function () {                                                    // 147\n  _.each(this._comps, function (c) { c.stop(); });                                         // 148\n  this._comps = [];                                                                        // 149\n};                                                                                         // 150\n                                                                                           // 151\nIron.WaitList = WaitList;                                                                  // 152\n                                                                                           // 153\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                         //\n// packages/iron_controller/lib/controller.js                                              //\n//                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                           //\n/*****************************************************************************/            // 1\n/* Imports */                                                                              // 2\n/*****************************************************************************/            // 3\nvar debug = Iron.utils.debug('iron:controller');                                           // 4\nvar Layout = Iron.Layout;                                                                  // 5\nvar DynamicTemplate = Iron.DynamicTemplate;                                                // 6\n                                                                                           // 7\n/*****************************************************************************/            // 8\n/* Private */                                                                              // 9\n/*****************************************************************************/            // 10\nvar bindData = function (value, thisArg) {                                                 // 11\n  return function () {                                                                     // 12\n    return (typeof value === 'function') ? value.apply(thisArg, arguments) : value;        // 13\n  };                                                                                       // 14\n};                                                                                         // 15\n                                                                                           // 16\n/*****************************************************************************/            // 17\n/* Controller */                                                                           // 18\n/*****************************************************************************/            // 19\nController = function (options) {                                                          // 20\n  var self = this;                                                                         // 21\n  this.options = options || {};                                                            // 22\n  this._layout = this.options.layout || new Layout(this.options);                          // 23\n  this._isController = true;                                                               // 24\n  this._layout._setLookupHost(this);                                                       // 25\n                                                                                           // 26\n  // grab the event map from the Controller constructor which was                          // 27\n  // set if the user does MyController.events({...});                                      // 28\n  var eventMap = Controller._collectEventMaps.call(this.constructor);                      // 29\n  this._layout.events(eventMap, this);                                                     // 30\n                                                                                           // 31\n  this.init(options);                                                                      // 32\n};                                                                                         // 33\n                                                                                           // 34\n/**                                                                                        // 35\n * Set or get the layout's template and optionally its data context.                       // 36\n */                                                                                        // 37\nController.prototype.layout = function (template, options) {                               // 38\n  var self = this;                                                                         // 39\n                                                                                           // 40\n  this._layout.template(template);                                                         // 41\n                                                                                           // 42\n  // check whether options has a data property                                             // 43\n  if (options && (_.has(options, 'data')))                                                 // 44\n    this._layout.data(bindData(options.data, this));                                       // 45\n                                                                                           // 46\n  return {                                                                                 // 47\n    data: function (val) {                                                                 // 48\n      return self._layout.data(bindData(val, self));                                       // 49\n    }                                                                                      // 50\n  };                                                                                       // 51\n};                                                                                         // 52\n                                                                                           // 53\n/**                                                                                        // 54\n * Render a template into a region of the layout.                                          // 55\n */                                                                                        // 56\nController.prototype.render = function (template, options) {                               // 57\n  var self = this;                                                                         // 58\n                                                                                           // 59\n  if (options && (typeof options.data !== 'undefined'))                                    // 60\n    options.data = bindData(options.data, this);                                           // 61\n                                                                                           // 62\n  var tmpl = this._layout.render(template, options);                                       // 63\n                                                                                           // 64\n  // allow caller to do: this.render('MyTemplate').data(function () {...});                // 65\n  return {                                                                                 // 66\n    data: function (func) {                                                                // 67\n      return tmpl.data(bindData(func, self));                                              // 68\n    }                                                                                      // 69\n  };                                                                                       // 70\n};                                                                                         // 71\n                                                                                           // 72\n/**                                                                                        // 73\n * Begin recording rendered regions.                                                       // 74\n */                                                                                        // 75\nController.prototype.beginRendering = function (onComplete) {                              // 76\n  return this._layout.beginRendering(onComplete);                                          // 77\n};                                                                                         // 78\n                                                                                           // 79\n/*****************************************************************************/            // 80\n/* Controller Static Methods */                                                            // 81\n/*****************************************************************************/            // 82\n/**                                                                                        // 83\n * Inherit from Controller.                                                                // 84\n *                                                                                         // 85\n * Note: The inheritance function in Meteor._inherits is broken. Static                    // 86\n * properties on functions don't get copied.                                               // 87\n */                                                                                        // 88\nController.extend = function (props) {                                                     // 89\n  return Iron.utils.extend(this, props);                                                   // 90\n};                                                                                         // 91\n                                                                                           // 92\nController.events = function (events) {                                                    // 93\n  this._eventMap = events;                                                                 // 94\n  return this;                                                                             // 95\n};                                                                                         // 96\n                                                                                           // 97\n/**                                                                                        // 98\n * Returns a single event map merged from super to child.                                  // 99\n * Called from the constructor function like this:                                         // 100\n *                                                                                         // 101\n * this.constructor._collectEventMaps()                                                    // 102\n */                                                                                        // 103\n                                                                                           // 104\nvar mergeStaticInheritedObjectProperty = function (ctor, prop) {                           // 105\n  var merge = {};                                                                          // 106\n                                                                                           // 107\n  if (ctor.__super__)                                                                      // 108\n    _.extend(merge, mergeStaticInheritedObjectProperty(ctor.__super__.constructor, prop));\n                                                                                           // 110\n  return _.has(ctor, prop) ? _.extend(merge, ctor[prop]) : merge;                          // 111\n};                                                                                         // 112\n                                                                                           // 113\nController._collectEventMaps = function () {                                               // 114\n  return mergeStaticInheritedObjectProperty(this, '_eventMap');                            // 115\n};                                                                                         // 116\n                                                                                           // 117\n// NOTE: helpers are not inherited from one controller to another, for now.                // 118\nController._helpers = {};                                                                  // 119\nController.helpers = function (helpers) {                                                  // 120\n  _.extend(this._helpers, helpers);                                                        // 121\n  return this;                                                                             // 122\n};                                                                                         // 123\n                                                                                           // 124\n/*****************************************************************************/            // 125\n/* Global Helpers */                                                                       // 126\n/*****************************************************************************/            // 127\nif (typeof Template !== 'undefined') {                                                     // 128\n  /**                                                                                      // 129\n   * Returns the nearest controller for a template instance. You can call this             // 130\n   * function from inside a template helper.                                               // 131\n   *                                                                                       // 132\n   * Example:                                                                              // 133\n   * Template.MyPage.helpers({                                                             // 134\n   *   greeting: function () {                                                             // 135\n   *    var controller = Iron.controller();                                                // 136\n   *    return controller.state.get('greeting');                                           // 137\n   *   }                                                                                   // 138\n   * });                                                                                   // 139\n   */                                                                                      // 140\n  Iron.controller = function () {                                                          // 141\n    //XXX establishes a reactive dependency which causes helper to run                     // 142\n    return DynamicTemplate.findLookupHostWithProperty(Blaze.getView(), '_isController');   // 143\n  };                                                                                       // 144\n                                                                                           // 145\n  /**                                                                                      // 146\n   * Find a lookup host with a state key and return it reactively if we have               // 147\n   * it.                                                                                   // 148\n   */                                                                                      // 149\n  Template.registerHelper('get', function (key) {                                          // 150\n    var controller = Iron.controller();                                                    // 151\n    if (controller && controller.state)                                                    // 152\n      return controller.state.get(key);                                                    // 153\n  });                                                                                      // 154\n}                                                                                          // 155\n/*****************************************************************************/            // 156\n/* Namespacing */                                                                          // 157\n/*****************************************************************************/            // 158\nIron.Controller = Controller;                                                              // 159\n                                                                                           // 160\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                         //\n// packages/iron_controller/lib/controller_client.js                                       //\n//                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                           //\n/*****************************************************************************/            // 1\n/* Imports */                                                                              // 2\n/*****************************************************************************/            // 3\nvar Layout = Iron.Layout;                                                                  // 4\nvar debug = Iron.utils.debug('iron:controller');                                           // 5\nvar defaultValue = Iron.utils.defaultValue;                                                // 6\n                                                                                           // 7\n/*****************************************************************************/            // 8\n/* Private */                                                                              // 9\n/*****************************************************************************/            // 10\nvar bindData = function (value, thisArg) {                                                 // 11\n  return function () {                                                                     // 12\n    return (typeof value === 'function') ? value.apply(thisArg, arguments) : value;        // 13\n  };                                                                                       // 14\n};                                                                                         // 15\n                                                                                           // 16\n/*****************************************************************************/            // 17\n/* Controller Client */                                                                    // 18\n/*****************************************************************************/            // 19\n/**                                                                                        // 20\n * Client specific init code.                                                              // 21\n */                                                                                        // 22\nController.prototype.init = function (options) {                                           // 23\n  this._waitlist = new WaitList;                                                           // 24\n  this.state = new ReactiveDict;                                                           // 25\n};                                                                                         // 26\n                                                                                           // 27\n/**                                                                                        // 28\n * Insert the controller's layout into the DOM.                                            // 29\n */                                                                                        // 30\nController.prototype.insert = function (options) {                                         // 31\n  return this._layout.insert.apply(this._layout, arguments);                               // 32\n};                                                                                         // 33\n                                                                                           // 34\n/**                                                                                        // 35\n * Add an item to the waitlist.                                                            // 36\n */                                                                                        // 37\nController.prototype.wait = function (fn) {                                                // 38\n  var self = this;                                                                         // 39\n                                                                                           // 40\n  if (!fn)                                                                                 // 41\n    // it's possible fn is just undefined but we'll just return instead                    // 42\n    // of throwing an error, to make it easier to call this function                       // 43\n    // with waitOn which might not return anything.                                        // 44\n    return;                                                                                // 45\n                                                                                           // 46\n  if (_.isArray(fn)) {                                                                     // 47\n    _.each(fn, function eachWait (fnOrHandle) {                                            // 48\n      self.wait(fnOrHandle);                                                               // 49\n    });                                                                                    // 50\n  } else if (fn.ready) {                                                                   // 51\n    this._waitlist.wait(function () { return fn.ready(); });                               // 52\n  } else {                                                                                 // 53\n    this._waitlist.wait(fn);                                                               // 54\n  }                                                                                        // 55\n                                                                                           // 56\n  return this;                                                                             // 57\n};                                                                                         // 58\n                                                                                           // 59\n/**                                                                                        // 60\n * Returns true if all items in the waitlist are ready.                                    // 61\n */                                                                                        // 62\nController.prototype.ready = function () {                                                 // 63\n  return this._waitlist.ready();                                                           // 64\n};                                                                                         // 65\n                                                                                           // 66\n/**                                                                                        // 67\n * Clean up the controller and stop the waitlist.                                          // 68\n */                                                                                        // 69\nController.prototype.stop = function () {                                                  // 70\n  this._waitlist.stop();                                                                   // 71\n};                                                                                         // 72\n                                                                                           // 73\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['iron:controller'] = {};\n\n})();\n","servePath":"/packages/iron_controller.js"}]